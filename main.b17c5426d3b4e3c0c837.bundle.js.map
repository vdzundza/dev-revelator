{"version":3,"file":"main.b17c5426d3b4e3c0c837.bundle.js","sources":["webpack:///./src/app/search-bar/search-bar.component.ts","webpack:///./src/app/assets-search-bar/assets-search-bar.component.ts"],"sourcesContent":["import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, OnInit, Output, ViewChild, AfterViewInit } from '@angular/core';\nimport { FormControl } from '@angular/forms';\nimport { NEVER, Observable, of, Subject } from 'rxjs';\nimport { debounce, delay, distinctUntilChanged, map, startWith, switchMap, tap } from 'rxjs/operators';\n\nimport { MatAutocomplete, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, MatChipInputEvent, MatChipList } from '@angular/material';\nimport { COMMA, ENTER, LEFT_ARROW } from '@angular/cdk/keycodes';\n\nfunction nestedCopy(array) {\n  return JSON.parse(JSON.stringify(array));\n}\n\nexport interface SearchValue {\n  type?: string;\n  value: string;\n}\nexport interface SearchItem {\n  title: string;\n  id?: string;\n  type?: string;\n  image?: string;\n  groupType?: string;\n  [key: string]: any;\n}\n\nexport interface Chip {\n  type: string;\n  value: SearchItem;\n}\nexport interface StateGroup {\n  groupTitle: string;\n  groupType?: string;\n  groupItems: SearchItem[];\n}\n\nexport interface SearchValue {\n  type?: string;\n  value: string;\n}\n\nexport interface SearchToken {\n  type: 'GENERAL' | 'SPECIFIC' | 'FREE';\n  value: SearchValue;\n}\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'rev-search-bar',\n  template: require('./search-bar.component.html'),\n  styles: [require('./search-bar.component.css')]\n})\nexport class SearchBarComponent implements OnInit, AfterViewInit {\n  @Output() debug = new EventEmitter();\n  @Output() updateSearchToken = new EventEmitter<SearchToken>();\n  @Output() updateChips = new EventEmitter();\n  @Output() clearChips = new EventEmitter();\n\n  @Input() placeholder = 'Search...';\n  @Input() multiple = true;\n  @Input() selectable = true;\n  @Input() removable = true;\n  @Input() addOnBlur = true;\n  @Input() showSearchTerms = false;\n  @Input() showTypeInfo = false;\n  @Input() showGroups = false;\n  @Input() allowDuplicates = false;\n  @Input() debounceTime = 400;\n  @Input() searchTerms = [];\n  @Input() freeTextSearchType = '';\n  @Input() searchTermsHelp = 'Search help...';\n  @Input() noDataText = 'No Data';\n  @Input() showDebug = false;\n\n  @ViewChild('searchInput', { static: false }) searchInput: ElementRef<HTMLInputElement>;\n  @ViewChild('searchInput', { read: MatAutocompleteTrigger, static: false }) trigger: MatAutocompleteTrigger;\n  @ViewChild('chipList', { read: MatChipList, static: false }) chipList: MatChipList;\n  @ViewChild('auto', { static: false }) matAutocomplete: MatAutocomplete;\n\n  chips: Chip[] = [];\n\n  separatorKeysCodes: number[] = [ENTER, COMMA];\n  searchCtrl = new FormControl();\n  searchTermsStatic = [];\n  stateGroupOptionsStatic: StateGroup[] = [];\n  hasData = false;\n  showNoData = false;\n  isSpecific = false;\n  isUpdating = false;\n\n  private localStateGroupOptionsStatic: StateGroup[] = [];\n\n  private searchStream = new Subject();\n  private search$ = this.searchStream.asObservable();\n\n  constructor(\n    private changeRef: ChangeDetectorRef\n  ) {\n  }\n\n  public setItems(items: StateGroup[] | any[]) {\n    return of(true)\n      .pipe(\n        map(() => nestedCopy(items)),\n        tap(() => this.localStateGroupOptionsStatic = items),\n        map((itemsToFilter: StateGroup[]): StateGroup[] => {\n          if (this.chips.length === 0) {\n            this.stateGroupOptionsStatic = itemsToFilter;\n          } else {\n            this.stateGroupOptionsStatic = this.filterAutosuggestionByChips(this.localStateGroupOptionsStatic);\n          }\n\n          this.stateGroupOptionsStatic = this.stateGroupOptionsStatic.filter((group: StateGroup) => group.groupItems.length > 0);\n          return this.stateGroupOptionsStatic;\n        })\n      );\n  }\n\n  toSearchItem(searchValue: SearchValue): SearchItem {\n    return {\n      id: null,\n      title: searchValue.value,\n      type: searchValue.type\n    };\n  }\n\n  addChip(chip: Chip): void {\n    this.chips.push(chip);\n    this.updateChips.emit({ type: 'ADD', chip });\n    this.releaseInputs();\n    if (this.trigger.panelOpen) {\n      this.trigger.closePanel();\n      this.setItems([]).subscribe().unsubscribe();\n      this.updateUiState([]);\n    }\n  }\n\n  ngAfterViewInit(): void {\n  }\n\n  ngOnInit(): void {\n    this.debug.emit(this);\n    this.searchCtrl.valueChanges.pipe(\n      startWith(null),\n      switchMap((item: string | SearchItem | null) => {\n        if (!item) {\n          return NEVER;\n        }\n\n        const token = this.getSearchToken();\n\n        if (!token) {\n          return NEVER;\n        }\n\n        return of(token);\n      })\n    ).subscribe((item: SearchToken) => {\n      this.searchTermsStatic = this.searchTerms.slice();\n      this.isSpecific = item.type === 'SPECIFIC';\n    });\n\n    this.search$.pipe(\n      switchMap((event) => {\n        const token = this.getSearchToken();\n        // console.log('search by token', token);\n\n        if (!token) {\n          return NEVER;\n        }\n\n        return of(event);\n      }),\n      debounce(val => of(true).pipe(delay(this.debounceTime))),\n      distinctUntilChanged()\n    )\n      .subscribe(($event: KeyboardEvent | ClipboardEvent) => {\n        if ($event.type === 'paste') {\n          // tslint:disable-next-line:no-string-literal\n          const clipboardData = ($event as ClipboardEvent).clipboardData || window['clipboardData'];\n          this.updateSearchToken.emit(this.getSearchToken(clipboardData.getData('text')));\n        } else {\n          const token = this.getSearchToken();\n          if (($event as KeyboardEvent).keyCode === ENTER) {\n            return;\n          }\n          this.updateSearchToken.emit(token);\n        }\n      });\n  }\n\n  add(event: MatChipInputEvent): void {\n    const input = event.input;\n    // Add chip only when MatAutocomplete is not open\n    // To make sure this does not conflict with OptionSelected Event\n    let token = this.getSearchToken();\n\n    if ((!this.matAutocomplete.isOpen) || (!this.hasData)) {\n      const freeText = event.value;\n      token = this.getSearchToken(freeText);\n      if (freeText && this.freeTextSearchType) {\n        if (!this.allowDuplicates) {\n          const inChips = this.chips\n            .filter(chip => chip.type === this.freeTextSearchType)\n            .findIndex(chip => chip.value.title === freeText) !== -1;\n          if (inChips) {\n            return;\n          }\n        }\n        if (token.type === 'SPECIFIC' && token.value.value !== '') {\n          // this.addChip({ type: token.value.type, value: this.toSearchItem(token.value) });\n        } else {\n          this.addChip({\n            type: this.freeTextSearchType,\n            value: {\n              id: null,\n              title: freeText,\n              groupType: this.freeTextSearchType\n            }\n          });\n\n          this.updateSearchToken.emit({\n            type: 'FREE',\n            value: {\n              type: this.freeTextSearchType,\n              value: freeText\n            }\n          });\n        }\n      }\n    }\n\n    this.releaseInputs();\n  }\n\n  remove(chip: Chip): void {\n    const index = this.chips.indexOf(chip);\n\n    if (index >= 0) {\n      this.chips.splice(index, 1);\n    }\n\n    this.updateChips.emit({ type: 'REMOVE' });\n    this.stateGroupOptionsStatic = this.filterAutosuggestionByChips(this.localStateGroupOptionsStatic);\n    if (this.chips.length === 0) {\n      this.clearChips.emit();\n    }\n  }\n\n  selected(event: MatAutocompleteSelectedEvent): void {\n    if (event) {\n      this.addChip({ type: event.option.value.groupType, value: event.option.value });\n      this.stateGroupOptionsStatic = this.filterAutosuggestionByChips(this.localStateGroupOptionsStatic);\n    }\n  }\n\n  onType($event: KeyboardEvent | ClipboardEvent) {\n    if (($event as KeyboardEvent).keyCode === LEFT_ARROW && this.chips.length > 0) {\n      // select the last chip for enabling arrow navigation\n      this.searchInput.nativeElement.blur();\n      this.chipList.focus();\n      this.chipList.chips.last.focus();\n      this.searchInput.nativeElement.click();\n    } else {\n      this.searchStream.next($event);\n    }\n  }\n\n  executeSearchQuery(searchStream: Observable<any>): any {\n    return of(true)\n      .pipe(\n        tap(() => this.isUpdating = true),\n        switchMap(() => searchStream),\n        switchMap((items) => {\n          // console.log('executeSearchQuery result', items);\n          return this.setItems(items);\n        }),\n        tap((items) => {\n          this.updateUiState(items);\n        })\n      );\n  }\n\n  getChips(): Chip[] {\n    return this.chips;\n  }\n\n  private filterAutosuggestionByChips(itemsToFilter: StateGroup[]) {\n    if (this.allowDuplicates) {\n      return nestedCopy(itemsToFilter);\n    }\n\n    return nestedCopy(itemsToFilter).map((group) => {\n      const groupType = group.groupType;\n      const chips = this.chips.filter((chip: Chip) => chip.type === groupType);\n\n      if (chips.length === 0) {\n        return group;\n      }\n\n      group.groupItems = group.groupItems.filter((item: SearchItem) => {\n        const inChip = chips.findIndex((chip) => chip.value.id === item.id);\n        return !(inChip !== -1);\n      });\n      return group;\n    });\n  }\n\n  private getSearchToken(text = null): SearchToken {\n    const DELIMITER = ':';\n    const searchText = text || this.searchInput.nativeElement.value;\n    if (!searchText) {\n      return null;\n    }\n\n    if (!this.showSearchTerms) {\n      return {\n        type: 'GENERAL',\n        value: { value: searchText }\n      };\n    }\n\n    if (searchText.includes(':')) {\n      const searchCriteria = searchText.split(DELIMITER);\n      if (searchCriteria.length > 2) {\n        return { type: 'GENERAL', value: { value: searchText } };\n      } else {\n        const [type, value] = searchCriteria;\n        if (this.searchTerms.findIndex((term: string) => term.toLowerCase() === type.toLowerCase()) !== -1) {\n          return { type: 'SPECIFIC', value: { type: type.toLowerCase(), value } };\n        } else {\n          return { type: 'GENERAL', value: { value: searchText } };\n        }\n      }\n\n    } else {\n      return {\n        type: 'GENERAL',\n        value: { value: this.searchInput.nativeElement.value }\n      };\n    }\n  }\n\n  private releaseInputs() {\n    this.searchInput.nativeElement.value = '';\n    this.searchCtrl.setValue(null);\n  }\n\n  private updateUiState(items: any) {\n    const total = items.reduce((count, group) => {\n      return count + group.groupItems.length;\n    }, 0);\n\n    this.isUpdating = false;\n    this.hasData = total > 0;\n    this.showNoData = !this.isUpdating && total === 0 && this.searchInput.nativeElement.value !== '';\n  }\n}\n","import {Component, EventEmitter, Input, OnInit, Output, ViewChild} from '@angular/core';\nimport {Apollo} from 'apollo-angular';\nimport gql from 'graphql-tag';\nimport {catchError, filter, map, switchMap} from 'rxjs/operators';\nimport {Chip, SearchBarComponent, SearchToken, StateGroup} from '../search-bar/search-bar.component';\nimport {NEVER, of, Subject, Subscription} from 'rxjs';\nimport {HttpClient} from '@angular/common/http';\nimport * as _ from 'lodash';\n\nexport class QueryFinder {\n  query: string;\n  groupType: string;\n  getStateGroup: (response: any) => StateGroup;\n}\n\n@Component({\n  selector: 'app-assets-search-bar',\n  template: require('./assets-search-bar.component.html'),\n  styles: [require('./assets-search-bar.component.css')]\n})\nexport class AssetsSearchBarComponent implements OnInit {\n  @ViewChild('searchBar', { static: false }) public searchBar: SearchBarComponent;\n\n  @Output() debug = new EventEmitter();\n\n  @Input() placeholder = 'Search...';\n  @Input() selectable = true;\n  @Input() removable = true;\n  @Input() addOnBlur = true;\n  @Input() useGroup = false;\n  @Input() showSearchTerms = true;\n  @Input() allowDuplicates = false;\n  @Input() allowMultipleSearchTypes = false;\n  @Input() debounceTime = 400;\n  @Input() queryLimit = 20;\n  @Input() searchTermsHelp: string;\n  @Input() assetsOrder: string;\n  @Input() freeTextSearchType = 'title';\n  @Input() noDataText = 'No Data';\n  @Input() showGroups = false;\n  @Input() showDebug = false;\n  @Input() showTypeInfo = false;\n\n  get searchQueries(): any {\n    return this.searchQueriesAllowed;\n  }\n\n  @Input('searchQueries')\n  set searchQueries(value: any) {\n    this.searchQueriesAllowed = value;\n  }\n\n  private searchQueriesAllowed = [];\n\n  private searchSubscription: Subscription = null;\n\n  private mainSubject = new Subject();\n  private main$ = this.mainSubject.asObservable();\n\n  private queryFinders: QueryFinder[] = [];\n\n  constructor(\n    private http: HttpClient,\n    private apollo: Apollo\n  ) {\n    this.queryFinders.push(\n      {\n        groupType: 'asset',\n        query: `\n        assets: Assets(title: $token, limit: $limit, order: \"title_desc\") {\n            page_info {\n              total\n            }\n            results {\n              id: pk\n              title\n              upc\n              image: item {\n                url\n              }\n            }\n        }\n        `,\n        getStateGroup: (response: any): StateGroup => {\n          return {\n            groupTitle: 'Assets',\n            groupType: 'asset',\n            groupItems: _.map(\n              _.get(response, 'assets.results', []),\n              (asset) => {\n                return _.assign(\n                  {},\n                  asset,\n                  {\n                    image: (asset.image.url || './assets/images/covers/vynil.svg'),\n                    groupType: 'asset'\n                  });\n              })\n          };\n        }\n      },\n      {\n        groupType: 'upc',\n        query: `\n         upcAssets: Upc(upc: $token, limit: $limit, order_field: \"title\", order_type: \"desc\") {\n            page_info {\n              total\n            }\n            results {\n              id: pk\n              title\n              upc\n              image: item {\n                url\n              }\n            }\n        }\n        `,\n        getStateGroup: (response: any): StateGroup => {\n          return {\n            groupTitle: 'Upc',\n            groupType: 'asset',\n            groupItems:\n              _.map(\n                _.get(response, 'upcAssets.results', []),\n                asset => {\n                  return _.assign(\n                    {},\n                    asset,\n                    {\n                      image: asset.image.url || './assets/images/covers/vynil.svg',\n                      groupType: 'asset'\n                    });\n                })\n          };\n        }\n      },\n      {\n        groupType: 'genre',\n        query: `\n        genre: Genres(name: $token, limit: $limit, order_field: \"name\", order_type: \"desc\") {\n          page_info {\n            total\n          }\n\n          results {\n            id\n            title: name\n          }\n        }\n      `,\n        getStateGroup: (response: any): StateGroup => {\n          return {\n            groupTitle: 'Genres',\n            groupType: 'genre',\n            groupItems:\n              _.map(\n                _.get(response, 'genre.results', []),\n                (genre) => {\n                  return _.assign(\n                    {},\n                    genre,\n                    {\n                      image: null,\n                      groupType: 'genre'\n                    });\n                }\n              )\n          };\n        }\n      },\n      {\n        groupType: 'company',\n        query: `\n        companies: Companies(name: $token, limit: $limit, order: \"name_desc\") {\n            page_info {\n              total\n            }\n            results {\n              id\n              title: name\n              image: logo {\n                url\n              }\n            }\n        }\n        `,\n        getStateGroup: (response: any): StateGroup => {\n          return {\n            groupTitle: 'Companies',\n            groupType: 'company',\n            groupItems:\n              _.map(\n                _.get(response, 'companies.results', []),\n                (company) => {\n                  return _.assign(\n                    {},\n                    company,\n                    {\n                      image: company.image.url,\n                      groupType: 'company'\n                    }\n                  );\n                }\n              )\n\n          };\n        }\n      },\n      {\n        groupType: 'artist',\n        query: `\n        artists: Artists(name: $token, limit: $limit, order: \"name_desc\") {\n          page_info {\n              total\n          }\n          results {\n              id\n              title: name\n              image: item {\n                url\n              }\n          }\n        }\n        `,\n        getStateGroup: (response: any): StateGroup => {\n          return {\n            groupTitle: 'Artists',\n            groupType: 'artist',\n            groupItems:\n              _.map(\n                _.get(response, 'artists.results', []),\n                (artist) => {\n                  return _.assign(\n                    {},\n                    artist,\n                    {\n                      image: artist.image.url || './assets/images/navbar/person-negative.svg',\n                      groupType: 'artist'\n                    });\n                }\n              )\n          };\n        }\n      },\n      {\n        groupType: 'country',\n        query: `\n        countries: Countries(name: $token, limit: $limit) {\n          page_info {\n              total\n          }\n          results {\n              id: value\n              title: printable_name\n          }\n        }\n        `,\n        getStateGroup: (response: any): StateGroup => {\n          return {\n            groupTitle: 'Countries',\n            groupType: 'country',\n            groupItems:\n              _.map(\n                _.sortBy(_.get(response, 'countries.results', []), [(o) => o.title]),\n                country => {\n                  return _.assign(\n                    {},\n                    country,\n                    {\n                      groupType: 'country',\n                      image: `https://www.countryflags.io/${country.id}/flat/64.png`\n                    });\n                }\n              )\n          };\n        }\n      },\n\n      {\n        groupType: 'storefront',\n        query: `\n        storefronts: StoreFronts(name: $token, limit: $limit) {\n        page_info {\n          total\n        }\n        results {\n            id: pk,\n            title:name,\n            image: item {\n                url\n            }\n            source: source {\n              name\n            }\n        }\n      }\n        `,\n        getStateGroup: (response: any): StateGroup => {\n          return {\n            groupTitle: 'Music Services',\n            groupType: 'storefront',\n            groupItems:\n              _.map(\n                _.sortBy(_.get(response, 'storefronts.results', []), [(o) => o.title]),\n                item => {\n                const title = item.title.split(' ');\n                let service = 'default';\n\n                if (title.length === 1) {\n                  service = title;\n                } else {\n                  service = title.slice(0, title.length - 1).join('').toLowerCase();\n                }\n\n                  return _.assign(\n                    {},\n                    item,\n                    {\n                  groupType: 'storefront',\n                  image: './assets/images/service_logo/' + service + '.svg'\n                });\n              })\n          };\n        }\n      }\n    );\n  }\n\n  ngOnInit() {\n    this.debug.emit(this);\n\n    this.searchSubscription = this.main$\n      .pipe(\n        filter((token: SearchToken) => {\n          return token && token.type !== 'FREE';\n        }),\n        map((token: SearchToken) => {\n          const query = this.buildQuery(token);\n          if (!query) {\n            return NEVER;\n          }\n\n          return this.apollo.watchQuery<any>({\n            fetchPolicy: 'no-cache',\n            query: query,\n            variables: {token: token.value.value, limit: this.queryLimit}\n          }).valueChanges.pipe(\n            catchError(() => of(null)),\n            filter((res: any): boolean => !!res),\n            map((res: any): any => res.data),\n            map((response: any): StateGroup[] => {\n              return this.queryFinders\n                .filter((finder: QueryFinder) => this.allowToFind(finder.groupType))\n                .map((finder: QueryFinder): StateGroup => finder.getStateGroup(response));\n            })\n          );\n        }),\n        switchMap((searchStream: any) => this.searchBar.executeSearchQuery(searchStream))\n      ).subscribe(() => {\n      console.log('end');\n    });\n\n  }\n\n  updateSearchToken(token: SearchToken) {\n    if (this.searchQueriesAllowed.length === 0) {\n      // throw new Error('should have at least one allowed query');\n      return;\n    }\n\n    this.mainSubject.next(token);\n  }\n\n  updateChips($event: any) {\n\n  }\n\n  clearChips($event: any) {\n\n  }\n\n  setItems(items) {\n    this.searchBar.setItems(items);\n  }\n\n  private allowToFind(groupType) {\n    const queryAllowed = this.searchQueriesAllowed.includes(groupType);\n    if (this.allowMultipleSearchTypes) {\n      return queryAllowed;\n    } else {\n      const inChipIndex = _.findIndex(this.searchBar.getChips(), (chip: Chip) => chip.type === groupType);\n      return inChipIndex === -1 && queryAllowed;\n    }\n  }\n\n  private buildQuery(token: SearchToken): any {\n    const { type } = token;\n    if (type === 'GENERAL') {\n      const queries = this.queryFinders\n        .filter((finder: QueryFinder) => this.allowToFind(finder.groupType))\n        .map(finder => finder.query);\n      return gql`query RootQuery(\n          $token: String,\n        $limit: Int!\n              ) {\n                  ${queries.concat('\\r\\n')}\n              }\n          `;\n    }\n  }\n}\n"],"mappings":"AAQA;;;;AC8YA;;AAjYA","sourceRoot":""}